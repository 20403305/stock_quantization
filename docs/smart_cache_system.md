# 智能缓存系统设计文档

## 概述

智能缓存系统旨在优化股票量化交易项目中的数据获取效率，通过智能存储和复用历史数据，减少不必要的数据请求，提高系统性能。

## 设计目标

1. **减少数据请求次数**：避免重复获取相同或重叠的时间范围数据
2. **智能数据合并**：自动合并不同时间范围的数据，形成完整的数据集
3. **增量数据获取**：只获取缺失的时间范围数据，补充现有缓存
4. **缓存生命周期管理**：自动管理缓存过期和清理

## 核心功能

### 1. 智能缓存管理器 (SmartCacheManager)

#### 主要特性
- **时间范围智能识别**：自动识别请求时间范围与缓存数据的重叠关系
- **增量数据获取**：只请求缺失的时间段数据
- **数据自动合并**：将新数据与缓存数据智能合并
- **缓存过期管理**：支持设置缓存过期时间（默认7天）

#### 核心方法

```python
def get_data_with_cache(self, symbol: str, start_date: str, end_date: str, 
                       data_fetcher: callable) -> pd.DataFrame:
    """
    智能获取数据，使用缓存优化
    """
```

### 2. 缓存策略

#### 数据存储格式
- 按股票代码分别存储
- CSV格式，包含完整的OHLCV数据
- 元数据文件记录缓存状态和范围

#### 缓存目录结构
```
data/cache/
├── time_series/
│   ├── 600519_SH.csv          # 贵州茅台数据
│   ├── 000001_SZ.csv          # 平安银行数据
│   └── cache_metadata.json    # 缓存元数据
└── stock_list_cache.csv       # 股票列表缓存
```

## 使用场景示例

### 场景1：完整覆盖（从缓存直接返回）
```python
# 第一次查询：获取大范围数据
data1 = dm.get_stock_data("600519", "2024-10-17", "2025-10-17")

# 第二次查询：子范围数据（完全在缓存范围内）
data2 = dm.get_stock_data("600519", "2025-01-01", "2025-09-01")
# ✅ 直接从缓存返回，无需网络请求
```

### 场景2：部分重叠（增量获取）
```python
# 已有缓存：2024-10-17 到 2025-10-17

# 查询需要补充的数据：2024-10-01 到 2025-01-01
data3 = dm.get_stock_data("600519", "2024-10-01", "2025-01-01")
# ✅ 只获取2024-10-01到2024-10-16的缺失数据
# ✅ 自动合并到缓存中
```

### 场景3：扩展范围（增量获取）
```python
# 已有缓存：2024-10-17 到 2025-10-17

# 查询扩展范围：2025-10-18 到 2025-12-31
data4 = dm.get_stock_data("600519", "2025-10-18", "2025-12-31")
# ✅ 只获取2025-10-18到2025-12-31的缺失数据
# ✅ 自动合并到缓存中
```

## API接口

### DataManager新增方法

```python
# 获取数据（默认使用缓存）
def get_stock_data(symbol, start_date, end_date, provider=None, 
                  market_type=None, use_cache=True)

# 清除缓存
def clear_cache(symbol=None)  # 清除指定股票或所有缓存

# 获取缓存信息
def get_cache_info(symbol=None)  # 获取指定股票或所有缓存信息
```

### 使用示例

```python
from src.data_provider.data_manager import get_data_manager

# 获取数据管理器
dm = get_data_manager()

# 1. 获取数据（使用智能缓存）
data = dm.get_stock_data("600519", "2024-10-01", "2025-10-17")

# 2. 查看缓存信息
cache_info = dm.get_cache_info("600519")
print(f"缓存记录数: {cache_info.get('record_count')}")
print(f"缓存范围: {cache_info.get('data_range')}")

# 3. 清除缓存
dm.clear_cache("600519")  # 清除指定股票缓存
dm.clear_cache()          # 清除所有缓存
```

## 性能优化

### 缓存命中率优化
- **时间范围智能匹配**：精确识别重叠范围
- **数据完整性检查**：确保缓存数据的连续性
- **自动数据合并**：避免重复存储相同数据

### 内存使用优化
- **按需加载**：只加载请求时间范围内的数据
- **数据分块存储**：支持大容量数据的高效管理
- **自动清理**：支持手动和自动缓存清理

## 错误处理

### 网络请求失败
- 当数据获取失败时，返回缓存中的可用数据
- 记录错误日志，但不中断程序执行

### 缓存文件损坏
- 自动检测损坏的缓存文件
- 重新获取数据并重建缓存
- 保持系统的鲁棒性

## 配置选项

### 缓存过期时间
```python
# 在SmartCacheManager中配置
self.cache_expire_days = 7  # 默认7天
```

### 缓存目录
```python
# 使用DATA_CONFIG中的配置
self.cache_dir = Path(str(DATA_CONFIG['data_dir'])) / 'cache'
```

## 测试验证

系统包含完整的测试用例，验证以下场景：
1. 缓存命中场景
2. 增量获取场景  
3. 缓存清除功能
4. 错误处理机制

## 扩展性设计

### 支持多数据源
系统设计支持多种数据提供商（yfinance、tushare、akshare），缓存机制与数据源无关。

### 可配置的缓存策略
未来可以支持更复杂的缓存策略，如：
- 按数据重要性设置不同的过期时间
- 支持缓存压缩和加密
- 分布式缓存支持

## 总结

智能缓存系统通过智能的时间范围管理和增量数据获取，显著提高了数据获取效率，特别适合量化交易中频繁查询历史数据的场景。系统设计兼顾了性能、可靠性和易用性，为量化策略开发提供了强大的数据支持。